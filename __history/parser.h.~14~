#ifndef _PARSER_H
#define _PARSER_H

#include "translation.h"
#include "index.h"
#include <sstream>
#include <math.h>
#include "arithmetic.h"
double string_to_double( const std::string& s )
{
std::istringstream i(s);
double x;
if (!(i >> x))
return 0;
return x;
}

enum state { start, digit,  word, symbol,error };

string z;
stack <string> number_stack;
stack <string> operation_stack;
stack <string> num;

string file_name = "detailed_answer_kr.txt";

char s[100] = ""; // строка, содержащая вводимое выражение
int i = 0;

string p = ""; // для преобразования char to string
LongArithmetic null(1);

class counter {
private :
	double element;
public:

	void Addition(double FirstElement, double SecondElement) { element =  FirstElement + SecondElement; } //сложение
	void Subtraction(double  FirstElement, double SecondElement) { element =  FirstElement - SecondElement; } //вычитание
	void Multiplication(double  FirstElement, double SecondElement) { element =  FirstElement * SecondElement; } //умножение
	void DivisionWithoutRemainder(double  FirstElement, double SecondElement) { element = (int) FirstElement / (int)SecondElement; } // деление без остатка
	void Mod(double  FirstElement, double SecondElement) { element = (int) FirstElement % (int)SecondElement; }
	double GetElement() {return element;}
};

LongArithmetic temp1(1000), temp2(1000);

class calculator {
	private:
string line;
public:

//преобразование выражения в опз
void opz(string operation) {
	if (indexk_op(operation) == 7) { number_stack.push(operation); }
	else if (indexk_op(operation) >= 2 ) {

		if (operation_stack.empty() || indexk_op(operation_stack.top()) < 2) {
			operation_stack.push(operation);
		}
	else {
		while (indexk_op(operation_stack.top()) >= indexk_op(operation)) {
			number_stack.push(operation_stack.top());
			operation_stack.pop();
			}
		operation_stack.push(operation);
		}
	}
	else if (indexk_op(operation) == 1) {operation_stack.push(operation);}
	else if (indexk_op(operation) == 0) {
		while (indexk_op(operation_stack.top()) != 1) {
			number_stack.push(operation_stack.top());
			operation_stack.pop();
		}
	operation_stack.pop();
	}
}

//вычисление выражения, записанного в ОПЗ
void answer(int number_system, string file_name, int accuracy) {
counter obj;
string s;
double n1, n2;
int CountAction = 1; // номер действия
ofstream f;
f.open(file_name.c_str(), ios::app);
while (!num.empty()) {
	if (indexk_op(num.top()) == 7) {
	operation_stack.push(num.top());
	num.pop();
	}
	else {
	   // длинная арифметика
		temp2.StrToVector(operation_stack.top().c_str());
		temp2.translation(number_system, 10 , file_name);
	   //обычная арифметика
		string SecondDigit  = operation_stack.top().c_str();
		for (int i=0;i < SecondDigit.length(); i++){
			if (SecondDigit [i]==','){SecondDigit [i]='.'; }
		}
		AnsiString SecondDigitDoubel = SecondDigit.c_str();

		double SecondDigitStringToDouble = string_to_double(SecondDigitDoubel.c_str());
		if (number_system==16) {
		n2=  translation_16(SecondDigit,number_system, accuracy, file_name);
		}else{
		n2 = translation_10(SecondDigitStringToDouble,number_system, accuracy, file_name);
		}

		operation_stack.pop();


		temp1.StrToVector(operation_stack.top().c_str());
		temp1.translation(number_system, 10 , file_name);


		string FirstDigit = operation_stack.top().c_str();

		for (int i=0;i < FirstDigit.length(); i++){
			if (FirstDigit[i]==','){FirstDigit[i]='.'; }
		}
		AnsiString FirstDigitDoubel = FirstDigit.c_str();
		double FirstDigitStringToDouble = string_to_double(FirstDigitDoubel.c_str());
		if (number_system==16) {
		n1=  translation_16(FirstDigit,number_system, accuracy, file_name);
		}else{
		n1 = translation_10(FirstDigitStringToDouble,number_system, accuracy, file_name);
		}

		operation_stack.pop();

		AnsiString CalculationResult;
			ofstream f;
		switch (indexk_op(num.top())) {

			case 2:
				if (num.top() == "+") {

				obj.Addition(n1, n2);
			   if(Form1->CheckBox1->Checked == false){CalculationResult = FloatToStr(translation_file(obj.GetElement(), number_system, file_name, accuracy)) ;
			f << CountAction << ")" << n1 << " + " << n2 << " = " <<   CalculationResult.c_str();
		}
				else {

				CalculationResult = (temp1 + temp2).OutputA().c_str();

				f << CountAction << ")" <<  temp1.VectorToStr() << " + " <<temp2.VectorToStr()<< " = " <<   CalculationResult.c_str();

				}


					CountAction++;
				}
				else {
				   obj.Subtraction(n1, n2);
				   if(Form1->CheckBox1->Checked == false)	CalculationResult = FloatToStr(translation_file(obj.GetElement(), number_system,file_name ,accuracy));
				   else CalculationResult = (temp1 - temp2).OutputA().c_str();
					CountAction++;
				}
			break;
			case 3:
				if (num.top() == "*") {
				  obj.Multiplication(n1, n2);
				  if(Form1->CheckBox1->Checked == false)	CalculationResult = FloatToStr(translation_file(obj.GetElement(), number_system, file_name,accuracy));
				  else CalculationResult = (temp1 * temp2).OutputA().c_str();
					CountAction++;
				}
				else if (num.top() == "div") {
					if ( temp2 ==  null || n2 == 0) {
					ShowMessage( "Ошибка.\nДеление на 0.\nНажмите \"OK\" и введите корректное выражение заново.");
				}
				else {
				obj.DivisionWithoutRemainder(n1,n2);
					 if(Form1->CheckBox1->Checked == false)	CalculationResult = FloatToStr(translation_file(obj.GetElement(), number_system, file_name,accuracy));
				  else { int x = temp2.VectorToInt() ;
					CalculationResult = (temp1 / x).OutputA().c_str();}
					CountAction++;}
			}  else if (num.top() == "%") {
				if ( temp2 ==  null) {
					ShowMessage( "Ошибка.\nДеление на 0.\nНажмите \"OK\" и введите корректное выражение заново.");
				}
				else {
					  obj.Mod(n1,n2);

				if(Form1->CheckBox1->Checked == false)	CalculationResult = FloatToStr(translation_file(obj.GetElement(), number_system, file_name,accuracy));
				  else {int x = temp2.VectorToInt() ;
					CalculationResult = (temp1 % x).OutputA().c_str(); }
					CountAction++;}
				}
			break;
		}
	f.close();
	num.pop();
	operation_stack.push(CalculationResult.c_str());

	}
}
}

};

string parser(string s, int number_system, string file_name, int accuracy) {
string sl = "", data = ""; // sl для формаривания слова , data для формирования числа
int count_bracket = 0;
state state = start;
calculator cl;
int i = 0; // счетчик в входной строке
char c, next_c; // c текущий символ строки , next_c cледующий
bool flag = false; // флаг для перехода в состояние "double_digit"

s = "( " + s + ") ";
while (i < s.length() - 1) {
	c = s[i];
	next_c = s[i + 1];
	string z = "";
	z = z + c;
	switch (state){
	case start:
		switch (index(c))
			{
			case 1: state = word;
			break;
			case 2: state = digit;
			break;
			case 3: state = symbol;
			break;
			case 4: state = start; i++;
			break;
			default: state = error;
			break;
			}
	break;
	case word:
		switch (index(c)){
			case 1:
				i++;
				sl = sl + c;
				if (index(next_c) == 4) {
					state = start;
					if (sl == "e") {
					  sl ="2,71";
					}
				if (sl == "п") {
					  sl = "3,14";
					}
					cl.opz(sl);
					sl = "";
				}
			break;
			default: state = error;
			break;
			}
			break;
	case digit:
		switch (index(c)){
			case 2:
				if (data.size()< 10000) {
					i++;
					data = data + c;
						if (index(next_c) == 4) {
							state = start;
							cl.opz(data);
							data = "";
							flag = false;

						}
				} else {
					ShowMessage("Ошибка.\nСлишком большое число.\nНажмите \"OK\" и введите корректное выражение заново.");
					return 0;
				 }
			break;
			default: state = error;
			break;
		}
	break;

	case symbol:
		switch (index(c)) {
			case 3:
				if (c=='(') { count_bracket +=1;}
				if (c==')') {count_bracket -=1;}
				if (index(next_c) == 4) { state = start; }
				cl.opz(z);
				i++;
				if (count_bracket < 0) {
					ShowMessage("Ошибка.\nНе правильно расставленны скобки.\nНажмите \"OK\" и введите корректное выражение заново.");
					return 0;
				}
			break;
			default: state = error;
			break;
		}
	break;
	case error:
		state = start;
		i = s.length();
		ShowMessage("Ошибка.\nНажмите \"OK\" и введите корректное выражение заново.");
		return 0;
	break;
	}
}

if (count_bracket!=0) {
	ShowMessage("Ошибка.\nНе правильно расставленны скобки. \nНажмите \"OK\" и введите корректное выражение заново.");
    return 0;
	}
// проверка стека при создании опз (когда строка разобрана)
if (!operation_stack.empty()) {
	while (operation_stack.empty()) {
		number_stack.push(operation_stack.top());
		operation_stack.pop();
		}
}
string print_opz = "";
//переворачиваем стек
while (!number_stack.empty()) {
	print_opz = number_stack.top() + ' ' + print_opz;
	num.push(number_stack.top());
	number_stack.pop();
}
ofstream f;
f.open(file_name.c_str(), ios::app);
f << ' ' + print_opz << endl << " 2.Подсчет выражения : \n";
f.close();

cl.answer(number_system, file_name, accuracy);

string ans = operation_stack.top();
return ans;

}

#define _CRT_SECURE_NO_WARNINGS
#endif

